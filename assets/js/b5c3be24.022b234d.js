"use strict";(self.webpackChunkbenson_doc=self.webpackChunkbenson_doc||[]).push([[844],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var o=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,l=function(e,t){if(null==e)return{};var n,o,l={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var s=o.createContext({}),u=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},d=function(e){var t=u(e.components);return o.createElement(s.Provider,{value:t},e.children)},c="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},k=o.forwardRef((function(e,t){var n=e.components,l=e.mdxType,r=e.originalType,s=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),c=u(n),k=l,m=c["".concat(s,".").concat(k)]||c[k]||p[k]||r;return n?o.createElement(m,a(a({ref:t},d),{},{components:n})):o.createElement(m,a({ref:t},d))}));function m(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=n.length,a=new Array(r);a[0]=k;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[c]="string"==typeof e?e:l,a[1]=i;for(var u=2;u<r;u++)a[u]=n[u];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}k.displayName="MDXCreateElement"},896:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>u});var o=n(7462),l=(n(7294),n(3905));const r={sidebar_position:2.5,sidebar_label:"[Google Docs] Optimization - Undo/Redo",title:"[Google Docs] Optimization - Undo/Redo",tags:["System Design","Optimization","Undo/Redo"]},a=void 0,i={unversionedId:"Plan/google-doc-system-optimization-undo-redo",id:"Plan/google-doc-system-optimization-undo-redo",title:"[Google Docs] Optimization - Undo/Redo",description:"https://github.com/MechaChen/undo-manager-lite",source:"@site/docs/Plan/google-doc-system-optimization-undo-redo.mdx",sourceDirName:"Plan",slug:"/Plan/google-doc-system-optimization-undo-redo",permalink:"/docs/Plan/google-doc-system-optimization-undo-redo",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Plan/google-doc-system-optimization-undo-redo.mdx",tags:[{label:"System Design",permalink:"/docs/tags/system-design"},{label:"Optimization",permalink:"/docs/tags/optimization"},{label:"Undo/Redo",permalink:"/docs/tags/undo-redo"}],version:"current",lastUpdatedAt:1748482728,formattedLastUpdatedAt:"May 29, 2025",sidebarPosition:2.5,frontMatter:{sidebar_position:2.5,sidebar_label:"[Google Docs] Optimization - Undo/Redo",title:"[Google Docs] Optimization - Undo/Redo",tags:["System Design","Optimization","Undo/Redo"]},sidebar:"tutorialSidebar",previous:{title:"[Google Docs] Interface",permalink:"/docs/Plan/google-doc-system-interface"},next:{title:"[Design Pattern] Chain of Responsibility pattern",permalink:"/docs/Plan/chain-of-responsibility-pattern"}},s={},u=[{value:"Undo/Redo demo",id:"undoredo-demo",level:2},{value:"Single undo stack and move by index",id:"single-undo-stack-and-move-by-index",level:2},{value:"2 Stacks - undo stack &amp; redo stack",id:"2-stacks---undo-stack--redo-stack",level:2},{value:"Comparison",id:"comparison",level:2},{value:"Optimization",id:"optimization",level:2},{value:"References",id:"references",level:2}],d={toc:u},c="wrapper";function p(e){let{components:t,...n}=e;return(0,l.kt)(c,(0,o.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("admonition",{title:"source code",type:"note"},(0,l.kt)("p",{parentName:"admonition"},(0,l.kt)("a",{parentName:"p",href:"https://github.com/MechaChen/undo-manager-lite"},"https://github.com/MechaChen/undo-manager-lite"))),(0,l.kt)("br",null),(0,l.kt)("h2",{id:"undoredo-demo"},"Undo/Redo demo"),(0,l.kt)("div",{style:{position:"relative",width:"100%",maxWidth:"700px",margin:"0 auto"}},(0,l.kt)("video",{controls:!0,style:{width:"100%",height:"auto",display:"block"},src:"https://github.com/user-attachments/assets/14d5548e-5ea5-42e0-b016-673fa6729107",alt:"Undo/Redo Optimization"})),(0,l.kt)("br",null),(0,l.kt)("br",null),(0,l.kt)("br",null),(0,l.kt)("p",null,"There are 2 ways to implement undo/redo mechanism:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"single undo stack and move by index (",(0,l.kt)("a",{parentName:"li",href:"https://github.com/MechaChen/undo-manager-lite/blob/main/src/hooks/useUndoRedoByIndex.ts"},"./src/hooks/useUndoRedoByIndex.ts"),")"),(0,l.kt)("li",{parentName:"ol"},"2 stacks - undo stack & redo stack (",(0,l.kt)("a",{parentName:"li",href:"https://github.com/MechaChen/undo-manager-lite/blob/main/src/hooks/useUndoRedoByTwoStack.ts"},"./src/hooks/useUndoRedoByTwoStack.ts"),")")),(0,l.kt)("br",null),(0,l.kt)("h2",{id:"single-undo-stack-and-move-by-index"},"Single undo stack and move by index"),(0,l.kt)("p",null,"Use a single stack to store the user's operation history, and"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"when user undo, move index backward (-1)"),(0,l.kt)("li",{parentName:"ul"},"when user redo, move index forward (+1)")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"const undo = () => {\n    const prevStep = Math.max(LOWER_BOUND, currentIndex - 1);\n    setCurrentIndex(prevStep);\n}\n\nconst redo = () => {\n    const nextStep = Math.min(UPPER_BOUND, currentIndex + 1);\n    setCurrentIndex(nextStep);\n}\n")),(0,l.kt)("br",null),(0,l.kt)("h2",{id:"2-stacks---undo-stack--redo-stack"},"2 Stacks - undo stack & redo stack"),(0,l.kt)("p",null,"Use 2 stacks to store the undo and redo histories"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"when user undo",(0,l.kt)("ol",{parentName:"li"},(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},"pop")," current state from undo stack"),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},"push")," current state to redo stack"),(0,l.kt)("li",{parentName:"ol"},"get the latest previous state from the last item in the undo stack"),(0,l.kt)("li",{parentName:"ol"},"set state with the latest previous version")))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"const undo = () => {\n    if (undoStack.current.length <= 1) {\n        return;\n    }\n\n    const currentValue = undoStack.current.pop();\n    const prevValue = undoStack.current[undoStack.current.length - 1];\n    redoStack.current.push(currentValue!);\n    setValue(prevValue);\n}\n")),(0,l.kt)("br",null),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"when user redo",(0,l.kt)("ol",{parentName:"li"},(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},"pop")," next state from redo stack"),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},"push")," redo state to undo stack"),(0,l.kt)("li",{parentName:"ol"},"set state with next version")))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"const redo = () => {\n    if (redoStack.current.length === 0) {\n        return;\n    }\n\n    const nextStep = redoStack.current.pop();\n    undoStack.current.push(value);\n    setValue(nextStep!);\n}\n")),(0,l.kt)("br",null),(0,l.kt)("h2",{id:"comparison"},"Comparison"),(0,l.kt)("table",null,(0,l.kt)("thead",null,(0,l.kt)("tr",null,(0,l.kt)("th",null,"Feature"),(0,l.kt)("th",null,"by index"),(0,l.kt)("th",null,"\ud83c\udfc6 by 2 stacks"))),(0,l.kt)("tbody",null,(0,l.kt)("tr",null,(0,l.kt)("td",null,"Implementation"),(0,l.kt)("td",null,"Single array + index"),(0,l.kt)("td",null,"Two stacks (undo/redo)")),(0,l.kt)("tr",null,(0,l.kt)("td",null,"Memory Usage"),(0,l.kt)("td",null,"\u2705 Less (single array)"),(0,l.kt)("td",null,"\u26a0\ufe0f More (two arrays)")),(0,l.kt)("tr",null,(0,l.kt)("td",null,"Code Complexity"),(0,l.kt)("td",null,"\u26a0\ufe0f Complex (index management)"),(0,l.kt)("td",null,"\u2705 Simple (intuitive push/pop)")),(0,l.kt)("tr",null,(0,l.kt)("td",null,"Error Risk"),(0,l.kt)("td",null,"\u26a0\ufe0f High (index out of bounds)"),(0,l.kt)("td",null,"\u2705 Low (no index management)")),(0,l.kt)("tr",null,(0,l.kt)("td",null,"Extensibility"),(0,l.kt)("td",null,"\u26a0\ufe0f Difficult (complex index logic)"),(0,l.kt)("td",null,"\u2705 Easy (simple to add features)")),(0,l.kt)("tr",null,(0,l.kt)("td",null,"Performance"),(0,l.kt)("td",null,"\u2705 Better (fewer slice operations)"),(0,l.kt)("td",null,"\u26a0\ufe0f Worse (maintain two arrays)")),(0,l.kt)("tr",null,(0,l.kt)("td",null,"Readability"),(0,l.kt)("td",null,"\u26a0\ufe0f Poor (need to understand index logic)"),(0,l.kt)("td",null,"\u2705 Good (clear semantics)")),(0,l.kt)("tr",null,(0,l.kt)("td",null,"Maintainability"),(0,l.kt)("td",null,"\u26a0\ufe0f Poor (prone to bugs)"),(0,l.kt)("td",null,"\u2705 Good (clear logic)")),(0,l.kt)("tr",null,(0,l.kt)("td",null,"Used by"),(0,l.kt)("td",null,(0,l.kt)("ul",null,(0,l.kt)("li",null,"Google Docs (early version)"),(0,l.kt)("li",null,"Microsoft Word (early version)"),(0,l.kt)("li",null,"Adobe Photoshop (early version)"))),(0,l.kt)("td",null,(0,l.kt)("ul",null,(0,l.kt)("li",null,(0,l.kt)("a",{href:"https://github.com/facebook/lexical/blob/main/packages/lexical-history/src/index.ts"},"Lexical")),(0,l.kt)("li",null,(0,l.kt)("a",{href:"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/UndoArchitecture/Articles/RegisteringUndo.html#//apple_ref/doc/uid/20000206-SW2"},"NSUndo manager")," (iOS, macOS standard)"),(0,l.kt)("li",null,"VS Code"),(0,l.kt)("li",null,"Sublime Text"),(0,l.kt)("li",null,"Atom"),(0,l.kt)("li",null,"Google Docs (current version)"),(0,l.kt)("li",null,"Microsoft Word (current version)"),(0,l.kt)("li",null,"Adobe Photoshop (current version)"),(0,l.kt)("li",null,"Figma")))))),(0,l.kt)("br",null),(0,l.kt)("h2",{id:"optimization"},"Optimization"),(0,l.kt)("p",null,"To prevent memory leak, we can setup undo stack size limit, and when new operation come in,\nwhich makes the stack exceed the limit, slice the stack by size of (current stack size - limit)"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"const push = (value: T) => {\n    let newUndoStack = undoStack.current.slice(0, currentIndex + 1);\n    newUndoStack.push(value);\n\n    // highlight-start\n    if (undoStack.current.length > limit) {\n        newUndoStack = newUndoStack.slice(undoStack.current.length - limit);\n    }\n    // highlight-end\n    undoStack.current = newUndoStack;\n    setCurrentIndex(newUndoStack.length - 1);\n}\n")),(0,l.kt)("br",null),(0,l.kt)("br",null),(0,l.kt)("h2",{id:"references"},"References"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/facebook/lexical/blob/main/packages/lexical-history/src/index.ts"},"Lexical History plugin source code")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://blog.julik.nl/2025/03/a-tiny-undo-stack"},"UI Algorithms: A Tiny Undo Stack")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=pR1r-1KGtNU"},"Build an Undo-Redo Hook in React with Keyboard Shortcut Support: Step-by-Step Tutorial"))),(0,l.kt)("br",null),(0,l.kt)("br",null))}p.isMDXComponent=!0}}]);