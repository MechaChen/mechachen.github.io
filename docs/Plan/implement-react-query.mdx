---
sidebar_label: '[Implement] 150 è¡Œå¯¦ç¾ React Query'
title: '[Implement] 150 è¡Œå¯¦ç¾ React Query'
tags:
  - Implement
  - react-query

---

:::info åŸå§‹ç¢¼åœ¨é€™ï¼Œå¯ä»¥åƒè€ƒ commit ç´€éŒ„ä¾†çœ‹çœ‹æ¯å€‹æ­¥é©Ÿçš„è®ŠåŒ–ï½
https://github.com/MechaChen/react-query-lite-implementation
:::

## å‰è¨€ï¼šç‚ºä»€éº¼è¦æœ‰ React Queryï¼Ÿ

åœ¨éå»æˆ‘å€‘éœ€è¦æœ‰ä¸€äº›å…¨åŸŸçš„ç‹€æ…‹ç®¡ç†åº«ï¼Œåƒæ˜¯ Redux ä¾†ç®¡ç†æ‰€æœ‰çš„å…¨åŸŸç‹€æ…‹ï¼Œä½†å°±æœƒé€ æˆä¸€äº›å•é¡Œï¼Œåƒæ˜¯ API çš„å…¨åŸŸè³‡æ–™è·Ÿ UI çš„å…¨åŸŸè³‡æ–™æ··å†ä¸€èµ·ï¼Œéƒ½å­˜åœ¨ Redux ä¸­ <br /><br />
é€™æ™‚ï¼Œå‡ºç¾äº†åƒ React Query é€™æ¨£çš„å¥—ä»¶ï¼Œä¾†æŠŠ å…¨åŸŸçš„ API è³‡æ–™ï¼Œç¨±ä½œ Server stateï¼Œå’Œ UI state åˆ†é–‹ä¾†ï¼Œåšåˆ°é—œæ³¨é»åˆ†é›¢ (Seperate of concern)ï¼Œä¸¦å° Server state åšä¸€äº›èƒŒå¾Œçš„è™•ç†ï¼Œåƒæ˜¯
- å¿«å– (cache)
- ç¾é¡¯ç¤ºé™³èˆŠè³‡æ–™ï¼Œåœ¨èƒŒå¾Œå»æ›´æ–° (stale while revalidate; SWR)
- æä¾›ä¸€äº›å¸¸ç”¨çš„å±¬æ€§ï¼Œåƒæ˜¯ `isLoading`, `isError`, `isSuccess`, `isFetching` ç­‰ç­‰

<br />

è®“æˆ‘å€‘çœå»éå¾€å¾ˆå¤šè™•ç†å…¨åŸŸ API è³‡æ–™çš„åŠŸå¤«

<br /><br />


## å¯¦ç¾ React Query API

<br /><br />

### è¦å¯¦ç¾çš„åŠŸèƒ½

å¦‚åœ–ç‰‡ä¸­æ‰€ç¤ºï¼Œæˆ‘å€‘è¦è®“ç¬¬ä¸€éš» API call çš„è³‡æ–™è¢«å†æ¬¡è¨ªå•æ™‚ï¼Œå¯ä»¥ç«‹å³çœ‹è¦‹ï¼Œä¸¦ä¸”åœ¨ä¸€æ®µæ™‚é–“å¾Œå»èƒŒåœ°è£¡æ›´æ–°è³‡æ–™

<iframe width="560" height="315" src="https://www.youtube.com/embed/Y_hmOKjx7Oc?si=0dhmxR00vbAQQqDq" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

<br /><br /><br />

### è¦å¯¦ç¾çš„ API

```jsx
import React from 'react';

export function QueryClientProvider() {}; // å°‡æ‰€æœ‰çš„ api queries data é€é Context å‚³éä¸‹å»

export class QueryClient {}; // å„²å­˜æœ‰æ‰€æœ‰çš„ api queries data
  
export function useQuery() {}; // custom hookï¼Œè®“æˆ‘å€‘å¯ä»¥å–å¾—ç¶“é stale-while-revalidate çš„ api data
```

<br /><br />

### ä¸€äº›å¤§å±€è§€

1. æˆ‘å€‘åˆ©ç”¨ Proxy pattern å°‡åŸæœ¬çš„ API call å¦å¤–åš cache ç­‰æ©Ÿåˆ¶ï¼Œæˆ– data GC çš„è™•ç†ï¼Œåœ¨ `createQuery`, `createQueryObserver` functions å¯ä»¥çœ‹è¦‹
2. æˆ‘å€‘åˆ©ç”¨ Observer patternï¼Œè®“æ‰€æœ‰ä½¿ç”¨åŒä¸€å€‹ query çš„ components éƒ½èƒ½ç›£è½åˆ° query çš„ç‹€æ…‹ï¼Œåœ¨ `createQueryObserver` ä¸­å¯ä»¥çœ‹è¦‹

<br /><br /><br />

å…ˆå°‡ `QueryClientProvider` å‚³å…¥æ–°çš„ Contextï¼ŒReactQueryDevtools è¨­ç‚º `null`

```jsx
const context = React.createContext();

export function QueryClientProvider({ children, client }) {
	return (
		<context.Provider value={client}>
			{children}
		</context.Provider>
	);
};

export function ReactQueryDevtools() {
	return null;
};
```

<br /><br />

### Step 1ï¼šè¨­å®š `useQuery`, `createQuery` åŸºæœ¬åŠŸèƒ½å’Œå±¬æ€§ï¼Œè®“ `useQuery` å¯ä»¥å„²å­˜ api data å’Œç‹€æ…‹

å°‡ `useQuery` å‚³å›åŸºæœ¬çš„å±¬æ€§

```jsx
export function useQuery() {
	return {
		status: 'loading',
		isLoading: false,
		data: undefined,
		error: undefined,
	}
}
```

<br /><br />


è¨­å®š `createQuery`ï¼Œç”¢ç”Ÿä¸€å€‹æ–°çš„ query
- æœ‰åŸºæœ¬çš„ api data å±¬æ€§
- å°‡ç¾åœ¨ call api çš„ function(`queryFn`) å›å‚³çš„çš„ promise å„²å­˜åˆ° `query.promise` ä¸­
- å¦‚æœå·²ç¶“æœ‰ promise åœ¨åŸ·è¡Œï¼Œå°±ä¸è¦å»åŸ·è¡Œ `queryFn`ï¼Œå›å‚³æ—¢æœ‰çš„ promise
- `queryFn` åŸ·è¡Œå®Œå¾Œï¼Œæ›´æ–°ç‹€æ…‹


```jsx
function createQuery({ queryKey, queryFn }) {
	let query = {
		promise: null,
		state: {
			status: 'idle',
			isLoading: false,
			data: undefined,
			error: undefined,
		},
		setState: (updater) => {
			query.state = updater(query.state);
		},
		fetch: () => {
			if (!query.promise) {
				query.promise = (async() => {
                    // å°‡ç‹€æ…‹æ”¹ç‚º loading
					query.setState((state) => ({
						...state,
						isLoading: true
					}));

					try {
						const data = await queryFn();
                        // æˆåŠŸå¾Œï¼Œå°‡ç‹€æ…‹æ”¹ç‚º success
                        // ä¸¦æŠŠ api data å„²å­˜åˆ° state ä¸­
						query.setState((state) => ({
							...state,
							status: 'success',
							data,
						}))
					} catch (error) {
                        // å¤±æ•—å¾Œï¼Œå°‡ç‹€æ…‹æ”¹ç‚º error
                        // ä¸¦æŠŠ error å„²å­˜åˆ° state ä¸­
						query.setState((state) => {
							...state,
							status: 'error',
							error,
						})
					} finally {
                        // ç„¡è«–æˆåŠŸæˆ–å¤±æ•—ï¼Œéƒ½å°‡ isLoading æ”¹ç‚º false
						query.setState((state) => {
							...state,
							isLoading: false,
						})
					}
				})();
			}

			return query.promise;
		}
	}
}
```

<br /><br />


### Step 2ï¼šå°‡ç›£è½åŒå€‹ api query çš„ component åŠ é€²ä¾†

æˆ‘å€‘æä¾› `subscribe` functionï¼Œè®“ component å¯ä»¥è¨‚é–± query çš„ç‹€æ…‹ï¼Œä¸¦ä¸”åœ¨ç‹€æ…‹æ”¹è®Šæ™‚ï¼Œé€šçŸ¥æ‰€æœ‰è¨‚é–±è€…

```jsx 
function createQuery({ queryKey, queryFn }) {
	let query = {
		promise: null,
        // highlight-start
		subscribers: [],
		subscribe: (subscriber) => {
			query.subscribers.push(subscriber);

			return () => {
                query.subscribers = query.subscribers
                    .filter((s) => s !== subscriber)
            }
		},
        // highlight-end
		setState: (updater) => {
            query.state = updater(query.state);
            // highlight-start
            query.subscribers.forEach((subscriber) => subscriber.notify());
            // highlight-end
        },
        ...
	}
}
```


<br /><br />


### Step 3ï¼šå°‡æ‰€æœ‰çš„ Queries é›†ä¸­åœ¨åŒä¸€å€‹åœ°æ–¹ï¼Œä¸¦ä¸”å¯ä»¥é€é `queryKey` æ‰¾åˆ°å°æ‡‰çš„ api query
<br />

```jsx
// éœ€è¦ä¸€å€‹åœ°æ”¾ queriesï¼Œé€™æ™‚å€™å°±éœ€è¦ QueryClient
export class QueryClient {
	constructor() {
		this.queries = [];
	}

    // å–å¾—ç‰¹å®šçš„ query
	getQuery = (options) => {
        // 1. åˆ©ç”¨ queryKey æ‰¾åˆ°å°æ‡‰çš„ query
		const queryHash = JSON.stringify(options.queryKey);
		let query = this.queries.find((query) => query.queryHash);

        // 2. å¦‚æœæ²’æœ‰ï¼Œå°±å»ºç«‹ä¸€å€‹æ–°çš„ query
		if (!query) {
			query = createQuery(this, options);
			this.queries.push(query);
		}

		return query;
	}
}

function creatQuery(client, { queryKey, queryFn }) {
	let query = {
        // highlight-start
		queryKey,
		queryHash: JSON.stringify(queryKey),
        // highlight-end
		promise: null,
        subscribers: [],
        state: {
            status: 'loading',
            isLoading: true,
            data: undefined,
            error: undefined,
        },
        ...
	}
}
```

<br /><br /><br />

### Step 4ï¼šå¯¦ç¾ `useQuery`ï¼Œè®“ component å¯ä»¥ç›£è½ api query çš„ç‹€æ…‹

```jsx
export function useQuery({ queryKey, queryFn }) {
	const client = useContext(context);

	const [, forceRerender] = useReducer((state) => state + 1, 0);

	const observerRef = useRef(null);

	if (!observerRef.current) {
		observerRef.current = createQueryObserver(
			client, 
			{ queryKey, queryFn }
		);
	}

	useEffect(() => {
		return observerRef.current.subscribe(forceRerender);
	}, [])

	return observerRef.current.getResult();
}


// å°‡ observer è¦åšçš„äº‹å¦å¤–ç”¨ä¸€å€‹ object ä¾†å°è£

function createQueryObserver(client, { queryKey, queryFn }) {
	const query = client.getQuery({ queryKey, queryFn });

	const observer = {
		notify: () => {},
		getResult: () => query.state,
		subscribe: (callback) => {
			observer.notify = callback;
			const unsubscribe = query.subscribe(observer);

			query.fetch();

			return unsubscribe;
		}
	}

	return observer;
}
```

<br /><br />

åˆ°é€™é‚Šæˆ‘å€‘ React Query çš„åŸºæœ¬åŠŸèƒ½å°±å®Œæˆäº† ğŸ¥³ğŸ¥³ğŸ¥³ï¼Œä½†æˆ‘å€‘é‚„å¯ä»¥åŠ ä¸Šä¸€äº›å®¢è£½åŒ–çš„åŠŸèƒ½ï¼Œåƒæ˜¯ `staleTime`, `gcTimeout` ç­‰ç­‰

<br /><br />

### (Extra) Step 5 : åŠ å…¥ `staleTime`

`staleTime`ï¼šç¾åœ¨çš„ api è³‡æ–™è¦ä¿å­˜å¤šä¹…


1. æŠŠä¸Šæ¬¡æˆåŠŸå–å¾— api çš„æœ€å¾Œçš„æ™‚é–“åŠ åˆ° query state è£¡
2. å°‡èˆŠè³‡æ–™è¦ä¿ç•™ `staleTime` çš„æ™‚é–“å‚³åˆ° `useQuery` è£¡
3. åœ¨ `createObserver` ä¸­ï¼Œç¢ºèªç¾åœ¨çš„æ™‚é–“èˆ‡ä¸Šæ¬¡è·Ÿæ–°çš„æ™‚é–“ç›¸æ¸›ï¼Œæœ‰æ²’æœ‰è¶…éè¦ä¿ç•™çš„æ™‚é–“ï¼Œå¦‚æœæœ‰ï¼Œé‡æ–° fetch

```jsx
export createQuery(client, { queryKey, queryFn }) {
	let query = {
		queryKey,
        queryHash: JSON.stringify(queryKey),
        promise: null,
        subscribers: [],
        state: {
            status: 'loading',
            isFetching: true,
            data: undefined,
            error: undefined,
        },
        ...,
		fetch: () => {
			if (!query.promise) {
				query.promise = (async () => {
					query.setState((state) => ({
                        ...state,
                        isFetching: true,
                        error: undefined,
                    }));

					try {
						const data = await queryFn();
						query.setState((state) => ({
							...state,
							status: 'success',
							data,
                            // highlight-start
							lastUpdated: Date.now(),
                            // highlight-end
						}))
					} catch (error) {
						query.setState((state) => {
							...state,
							status: 'error',
							error,
						})
					} finally {
						query.setState((state) => {
							...state,
							isLoading: false,
						})
					}
				})();
			}

			return query.promise;
		}
	}

	return promise
}


export function useQuery({
    queryKye,
    queryFn,
    // highlight-start
    staleTime,
    // highlight-end
}) {
	const client = useContext(context);

    const [, forceRender] = useReducer((state) => state + 1, 0);

    const observerRef = useRef(null);

	if (!observerRef.current) {
		observerRef.current = createQueryObserver(
			client,
			{
                queryKey,
                queryFn,
                // highlight-start
                staleTime,
                // highlight-end
            }
		);
	}
    
	useEffect(() => {
        return observerRef.current.subscribe(forceRender);
    }, []);

    return observerRef.current.getResult();
}
		
function createQueryObserver(
    client,
    { 
        queryKey, 
        queryFn, 
        // highlight-start
        staleTime,
        // highlight-end
    }
) {
	const query = client.getQuery({ queryKey, queryFn });

	const observer = {
		notify: () => {},
        getResult: () => query.state,
		subscribe: (callback) => {
			observer.notify = callback;
			const unsubscribe = query.subscribe(observe);

            // åœ¨å‘¼å« useQuery çš„æ™‚å€™ï¼ŒåŸ·è¡Œæœ‰ç‰¹å®šæ¢ä»¶çš„ fetch
            // highlight-start
			observer.fetch();
            // highlight-end

			return unsubscribe;
		},
		fetch: () => {
            // highlight-start
			const isNotFetchBefore = !query.state.lastUpdated;
			const isStillFresh = (Date.now() - query.state.lastUpdated) > staleTime;
			
			if (isNotFetchBefore || isStillFresh) {
				query.fetch();
			}
            // highlight-end
		}
	}
	
    return observer;
}
```

<br /><br />


### (Extra) Step 6ï¼šåŠ å…¥ `gcTimeout`

`gcTimeout`ï¼šåœ¨æŒ‡å®šçš„ä¸€æ®µæ™‚é–“å¾Œï¼Œå°‡æ­¤ api data ç§»é™¤æ‰ï¼Œå°±ç®—æ²’æœ‰åœ¨é‡æ–° fetch

1. åœ¨ `useQuery`, `createQueryObserve` å°‡ä½¿ç”¨è€…æŒ‡å®šçš„ `cacheTime` å‚³å…¥
2. åœ¨ `createQuery` ä¸­ï¼Œåœ¨è¨»å†Šæ™‚ï¼Œç•¶è‡³å°‘æœ‰ä¸€å€‹ component è¨»å†Šè©² query æ™‚ï¼Œå°±ä¸è¦å°‡æ­¤ query å›æ”¶æ‰ï¼Œä½†æ²’æœ‰è¨»å†Šè€…å°±æœƒæ”¶æ‰

```jsx
function createQuery(
    client,
    { 
        queryKey,
        queryFn,
        // highlight-start
        cacheTime = 5 * 60 * 1000
        // highlight-end
    }
) {
	let query = {
		queryKey,
        queryHash: JSON.stringify(queryKey),
        promise: null,
        subscribers: [],
        // highlight-start
		gcTimeout: null,
        // highlight-end
		state: {
            status: 'loading',
            isFetching: true,
            data: undefined,
            error: undefined,
        },
		subscribe: (subscriber) => {
			query.subscribers.push(subscriber);

            // highlight-start
			query.unscheduleGC();
            // highlight-end

			return () => {
				query.subscribers = query.subscribers.filter((s) => s !== subscriber);

                // highlight-start
                // ç•¶æ­¤ query æ²’æœ‰è¨‚é–±è€…æ™‚ï¼Œå°±å¯ä»¥ Garbage Collection
				if (!query.subscribers.length) {
					query.scheduleGC();
				}
                // highlight-end
			}
		},
        // highlight-start
		scheduleGC: () => {
			query.gcTimeout = setTimeout(() => {
				clients.queries = client.queries.filter((q) => q !== query)
			}, cacheTime);
		},
		unscheduleGC: () => {
			clearTimeout(query.gcTimeout);
		},
        // highlight-end
        ...
	}
}


export function useQuery({ ..., cacheTime }) {
	...
	if (!observerRef.current) {
		observerRef.current = createQueryObserver(
			client,
			{ queryKey, queryFn, staleTime, cacheTime },
		)
	}
	
	...
}

function createQueryObserver(client, { ..., cacheTime }) {
	const query = client.getQuery({ queryKey, queryFn, cacheTime });
	...
}
```

<br /><br />

## æœ€çµ‚ç¨‹å¼ç¢¼

```jsx showLineNumbers
import React, { useContext, useRef, useReducer, useEffect } from 'react';

const context = React.createContext();

export function QueryClientProvider({ children, client }) {
    return <context.Provider value={client}>{children}</context.Provider>;
};

// éœ€è¦ä¸€å€‹åœ°æ”¾ queriesï¼Œé€™æ™‚å€™å°±éœ€è¦ QueryClient
export class QueryClient {
    constructor() {
        this.queries = [];
    }

    // å–å¾—ç‰¹å®šçš„ query
    getQuery = (options) => {
        // 1. åˆ©ç”¨ queryKey æ‰¾åˆ°å°æ‡‰çš„ query
        const queryHash = JSON.stringify(options.queryKey);
        let query = this.queries.find((query) => query.queryHash === queryHash);

        // 2. å¦‚æœæ²’æœ‰ï¼Œå°±å»ºç«‹ä¸€å€‹æ–°çš„ query
        if (!query) {
            query = createQuery(this, options);
            this.queries.push(query);
        }

        return query;
    }
};

function createQuery(client, { queryKey, queryFn, cacheTime = 5 * 60 * 1000 }) {
    let query = {
        queryKey,
        queryHash: JSON.stringify(queryKey),
        promise: null,
        subscribers: [],
        gcTimeout: null,
        state: {
            status: 'loading',
            isFetching: true,
            data: undefined,
            error: undefined,
            // é¿å…é‡è¤‡è§¸ç™¼ (deduppling)ï¼Œå¦‚æœæœ‰ queryFn æ­£åœ¨åŸ·è¡Œï¼Œå°±ä¸è¦å†åŸ·è¡Œä¸€æ¬¡
        },
        subscribe: (subscriber) => {
            query.subscribers.push(subscriber);

            query.unscheduleGC();

            return () => {
                query.subscribers = query.subscribers.filter((s) => s !== subscriber);

                // ç•¶æ­¤ query æ²’æœ‰è¨‚é–±è€…æ™‚ï¼Œå°±å¯ä»¥ Garbage Collection
                if (!query.subscribers.length) {
                    query.scheduleGC();
                }
            }
        },
        scheduleGC: () => {
            query.gcTimeout = setTimeout(() => {
                client.queries = client.queries.filter((q) => q !== query);
            }, cacheTime);
        },
        unscheduleGC: () => {
            clearTimeout(query.gcTimeout);
        },
        setState: (updater) => {
            // updater é¡ä¼¼ reducerï¼Œç”¨ä¾†æ”¹è®Š state
            query.state = updater(query.state);
            query.subscribers.forEach((subscriber) => subscriber.notify());
        },
        fetch: () => {
            if (!query.promise) {
                query.promise = (async () => {
                    query.setState((state) => ({ ...state, isFetching: true, error: undefined }));
    
                    try {
                        const data = await queryFn();
                        query.setState((state) => ({ ...state, status: 'success', data, lastUpdated: Date.now() }));
                    } catch (error) {
                        query.setState((state) => ({ ...state, status: 'error', error }));
                    } finally {
                        query.promise = null;
                        query.setState((state) => ({ ...state, isFetching: false }));
                    }
                })()
            }

            return query.promise;
        },
    }

    return query;
}


export function useQuery({ queryKey, queryFn, staleTime, cacheTime }) {
    const client = useContext(context);

    const [, forceRender] = useReducer((state) => state + 1, 0);

    const observerRef = useRef(null);

    if (!observerRef.current) {
        observerRef.current = createQueryObserver(client, {
            queryKey,
            queryFn,
            staleTime,
            cacheTime,
        });
    }

    useEffect(() => {
        return observerRef.current.subscribe(forceRender);
    }, []);

    return observerRef.current.getResult();
};

// è·Ÿ useQuery çµåˆ
function createQueryObserver(client, { queryKey, queryFn, staleTime = 0, cacheTime }) {
    const query = client.getQuery({ queryKey, queryFn, cacheTime });

    const observer = {
        notify: () => {},
        getResult: () => query.state,
        // åœ¨å‘¼å« useQuery çš„æ™‚å€™ï¼Œå°±æœƒåŸ·è¡Œé€™å€‹å‡½å¼
        subscribe: (callback) => {
            observer.notify = callback;
            const unsubscribe = query.subscribe(observer);

            // åœ¨å‘¼å« useQuery çš„æ™‚å€™ï¼ŒåŸ·è¡Œæœ‰ç‰¹å®šæ¢ä»¶çš„ fetch
            observer.fetch();

            return unsubscribe;
        },
        // fetch å‰å…ˆæª¢æŸ¥ä¿ç•™èˆŠè³‡æ–™çš„æ™‚é–“ staleTime æ˜¯å¦éæœŸï¼ŒéæœŸå†å» fetch
        fetch: () => {
            if (
                !query.state.lastUpdated
                || Date.now() - query.state.lastUpdated > staleTime
            ) {
                query.fetch();
            }
        }
    }

    return observer;
}

export function ReactQueryDevtools() {
    return null;
};
```

<br /><br /><br />

### åƒè€ƒè³‡æº

- [Let's Build React Query in 150 Lines of Code! â€“ Tanner Linsley, React Summit Remote Edition 2021 (youtube.com)](https://www.youtube.com/watch?v=9SrIirrnwk0)

<br /><br /><br />