---

sidebar__label: '[Frontend] Part 1.1 - Basic - 測試命名＆架構'
title: '[Frontend] Part 1.1 - Basic - 測試命名＆架構'

---

## 為什麼測試的命名很重要？

根據 AOUT 好的單元測試的三大支柱，為了測試具有
- Readable：可讀的
- Trustworthy：可信賴的

<br />

才能讓專案後續
- Bugless：減少 bug
- Updatable：後續若有更新也不會怕出錯，我們可以透過 Unit test 快速的自動測試
- Documented：直接告訴其他開發者我們的曾經做了哪些需求，當初我們期待的結果是什麼，而不用再讀 code

<br />

因此，我們需要重視測試的命名，不僅是為了減少 bug，更多的是為了後續能放心的更新和記得當初做了什麼需求


<br />


## 有推薦的命名方式嗎？

根據 AOUT(Art of Unit Testing)，作者 Roy 根據自身經驗發想了 U.S.E. 命名法則，
分別代表：

<br />

U：Unit of Work，受測的工作單位 <br />
S：Scenario，當下的情境 <br />
E：Expected Result，預期結果 <br />

<br />

包含這三個元素，就可以完整的描述測試的情境
就像是英文句子，包含
- 主體 ( Unit of Work )
- 原因 ( Scenario )
- 結果 ( Expected Result )

就可以很完整的描述一件事的來龍去脈

範本如下：
```jsx
// test case template

describe('<Unit of Work>', () => {
	test('when <Scenario>, should <Expected Resutlt>', () => {
    // your testing code
	});
});
```


```jsx
// test case example

describe('LoadingButton', () => {
	test('when isLoading prop is true, should show loading icon', () => {
    // your testing code
	});
});
```

<br /><br />



## 撰寫測試程式碼

### 有寫程式碼最好的模式嗎？

目前軟體業已經有 2 套撰寫測試程式碼的模式，包含：
- 3A pattern：Arrange, Act, Assert
- GWT pattern：Given, When, Then

<br />

現今較廣為人知和較多人採用的是 3A pattern，
故我們以下程式碼都會以此 pattern 撰寫

以下是 3A pattern 的簡介：
- Arrange：準備所有測試要用的資源
- Act：執行測試
- Assert：斷定測試結果是否符合預期

<br />

以下是 3A pattern 的範例

```jsx
describe('SubmitButton', () => {
	test('when loading, should show loading icon', () => {
		// Arrange: declare the data or variables we need
		const props = { isLoading: true };
	
		// Act: actually doing the process
		const { getByTestId } = render(<SubmitButton {...props} />);
		const loadingIcon = getByTestId('loadingIcon');
	
		// Assert: judge whether the result is expected as we thought
		expect(loadingIcon).toBeVisible();
	});
});
```

<br /><br />


## 一個測試只測一個結果

:::note Best assert practice
**Testing only one thing, only 1 concern in 1 test case**
:::

<br />

我們在每一個測試案例，只要測一個結果就好了，
如果在相同的情境下有多個預期的結果，我們應該每一個結果都另寫一個 test case，

舉例如下：

當我們要提交表單按下 submit button 正在 loading 時，
button 應該要顯示 loading icon 和被 disabled

<br />

以下是錯誤範例：

```jsx
describe('SubmitButton', () => {
	test('when loading, should show loading icon and disabled', () => {
		// Arrange
		const props = { isLoading: true };
	
		// Act
		const { getByTestId } = render(<SubmitButton {...props} />);
		const submitBtn = getByTestId('submitBtn');
		const loadingIcon = getByTestId('loadingIcon');
	
		// Assert
		// ❌ Assert too many thing in a single test case
		expect(loadingIcon).toBeVisible();
		expect(submitBtn).toBeDisabled();
	});
});

```

<br />

以下是正確範例：

```jsx
describe('SubmitButton', () => {
	test('when loading, should show loading icon', () => {
		// Arrange
		const props = { isLoading: true };
	
		// Act
		const { getByTestId } = render(<SubmitButton {...props} />);
		const loadingIcon = getByTestId('loadingIcon');
	
		// Assert
		// ✅ Assert only 1 thing in 1 test case
		expect(loadingIcon).toBeVisible();
	});

	test('when loading, should be disabled', () => {
		// Arrange
		const props = { isLoading: true };
	
		// Act
		const { getByTestId } = render(<SubmitButton {...props} />);
		const submitBtn = getByTestId('submitBtn');
	
		// Assert
		// ✅ Assert 1 thing in 1 test case
		expect(submitBtn).toBeDisabled();
	});
});
```

<br />

這樣的好處是：
- 每個測試案例的敘述 & 程式碼變短了，可讀性上升
- 當有測試失敗時，我們馬上就知道是哪個結果沒有符合預期，不用猜是這個測試案例的哪個結果失敗
